/**
 * 	An implementation of this interface by a public class named Game must
 *  be uploaded to the initial configuration page along with the other
 *  game components to define a new game in the Bot!Battle! system.
 *  
 *  For your convenience in generating JSON strings, version 1.1.1 of the 
 *  following library is provided in the class path of the GameManager.
 *  https://code.google.com/p/json-simple/
 *  
 *  If you'd like or require additional libraries they can be added to the class path 
 *  easily by modifying the following export in /BotBattleApp/custom_modules/BotBattlePaths.js
 *  	module.exports.gameManagerClassPath
 */
public interface GameInterface {
 
  /**
   * Currently unused.
   * @return A user friendly game name. E.g. Save The Island or Tic-Tac-Toe
   */
  public String getName();
  
  /**
   * Called before any other interface methods. Must setup the game to be ready to
   * play. Most likely involves initializing the board and any private members.
   * The default no-arg constructor is also called before this if you'd like to
   * perform some setup there.
   * @param gameType A GameType enum specifying BotVsBot or BotVsHuman.
   */
  public void initializeGame(GameType gameType);
  
  /**
   * @return A string containing a valid Initial GameState as defined in the documentation.
   */
  public String getInitialGameStateJSON();
  
  /** The move and stderr messages are recommended to be included 
   *	in the debugData attribute of the returned JSON String. Your client 
   *	side game.js file can then display these in the lists at the 
   *	bottom of the Test Arena, as done for the Save The Island game.
   *
   * @param jsonSafeMove The player's move, cleaned with JSONSimple's 
   *	JSONValue.toJSONString(...) method.
   * @param jsonSafeStderrArray A String representing a JSON array of 
   *	new line separated strings received from the player since the 
   *	last turn, cleaned with JSONSimple's JSONValue.toJSONString(...) method.
   * @param player Either 1 or 2.
   * @return A string containing a valid Mid GameState as defined in the documentation.
   */
  public String getMidGameStateJSON(String jsonSafeMove, String jsonSafeStderrArray, int player);
  
  /**
   * @return A string containing a valid final GameState as defined in the documentation.
   */
  public String getFinalGameStateJSON();
  
  /**
   * If the move was invalid, please provide a helpful description of the violation.
   * This description will be sent to the Test Arena, along with the exact move text 
   * generated by the bot or human player to be logged in the Event Log.
   * @param move The last line received from the players standard output stream
   * @param player Either 1 or 2.
   * @return
   *	If the move was valid: null  
   * 	If the move was invalid: [String describing the reason the move was invalid]
   */
  public String validateMove(String move, int player);
  
  /**
   * Will be called only if move was valid according to validateMove. Expected to
   * evaluate and store any changes to the game state as a result of this move.
   * Note: getMidGamestate will be called immediately after this.
   * @param move The last line received from the players standard output stream
   * @param player Either 1 or 2.
   */
  void updateBoard(String move, String stderr, int player);
  
  /**
   * Used as the control for the main game loop. Once this returns true, the
   * game is considered over and the GameInstance will call getFinalGameStateJSON.
   * @return true if the game is over, false otherwise.
   */
  boolean isGameOver();
  
  /**
   * Number of milliseconds to wait for a bot's move (via their stdout stream) before
   * giving up and reporting a "null" move.
   */
  int getBotTimeoutInMilliseconds();
  
  /**
   * Number of milliseconds to wait for a human's move (via their stdout stream) before
   * giving up and reporting a "null" move.
   */
  int getHumanTimeoutInMilliseconds();
  
  /**
   * Return the player number of the current turn (iteration of the game loop). 
   * This player will be asked for a move, and that move will be submitted to 
   * the next calls to validateMove and updateBoard.
   * @return Either 1 or 2
   */
  int getPlayerForCurrentTurn();
  
  /**
   * This method will be called when getPlayerForCurrentTurn() has indicated that it's
   * player 1's turn. This string will be sent verbatim to standard input stream of the 
   * bot playing as player 1.
   * @return Player 1's view of the game board.
   */
  String getPlayerOneBoard();
  
  /**
   * This method will be called when getPlayerForCurrentTurn() has indicated that it's
   * player 2's turn. This string will be sent verbatim to standard input stream of the 
   * bot playing as player 2. Or ignored if player two is a human. 
   * 
   * Note in the case of human players in the test arena, it's the job of game.js 
   * to display the human input elements to the user. The recommendation is to 
   * include the necessary information to generate the human input elements in 
   * the gameData attribute of the midGameState preceding the human's turn.
   * @return Player 2's view of the game board.
   */
  String getPlayerTwoBoard();
  
  /**
   * Currently unused, except by Incomplete/TournGameInstance.
   *  
   * The idea was to combine both player 1 and player 2's view of the board into an
   * overall string representation of the board. User feedback of the test arena indicated 
   * they'd rather see the actual playerOne and playerTwo boards using the other getters above.
   * 
   * In all likelihood this method is not needed at all and could be removed from the interface.
   * @return An overall view of the game board.
   */
  String getCompleteBoard();
}
  
