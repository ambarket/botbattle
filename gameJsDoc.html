<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Bot!Battle! Documentation</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Bot!Battle!</h1>
	  <br>
      <a href="./index.html" class="btn">Main</a>
      <a href="./downloads.html" class="btn">Downloads</a>
      <a href="./documentation.html" class="btn">Documentation</a>
      <a href="./support.html" class="btn">Support</a>
      <a href="./about.html" class="btn">About</a>
      <br>
	  <h2> Creating a Game! </h2>
	  <a href="./createAGame.html" class="btn">Creating a Game</a>
      <a href="./testArenaDevelopersGuide.html" class="btn">Test Arena Developer's Guide</a>
      <a href="./gameJsDoc.html" class="btn">Game js Documentation</a>
      <a href = "./jsonGameStates.html" class="btn"> JSON Game States</a>
      <a href = "./GameInterfaceJavaDoc/index.html" class="btn"> GameInterface JavaDoc</a>

    </section>

    <section class="main-content">

<h1> Game Javascript </h1>
	<p>
		Your Game java class is responsible for implementing all game logic required for validating moves, tracking the state of the game, and
		determining when someone has won or the game has otherwise ended. Your game javascript file is then responsible for 
		actually animating and presenting the results of the game to the user in the test arena. 
     
    <p> JSON Game states are used to communicate between your java Game class and your Game javascript file. 
		See <a href = "./jsonGameStates.html" > JSON Game States</a> to learn more about
		these game states, what components they must include, and see some examples.
		
	<p> Your game javascript file must implement the following functions as properties of a global object named GAME. These functions
		will be invoked by the built in testArena.js file when necessary.
		
	<ul>
		<li><a id="setExtraGameControls"><i>setExtraGameControls()</i> </a>
		<ul><li><p> Will be called after each page state transition. The idea is that based on the new value of TEST_ARENA.state
			you may want to add or remove your own custom HTML elements from the Test Arena. In the Save The Island game,
			this was used for displaying the "Toggle Tiles" button when the page state was "gameStarted".</p></li></ul>
				
		<li><a id="resetGameboard"><i>resetGameboard(callback)</i></a>
			<ul>
				<li><p>Called upon receipt of the initialGameState. Should completely clear out and lose reference to 
				any data or state related to a previous game that was played. Since the test arena is never reloaded, 
				its important to make sure this is done fully at this step to avoid quirky behavior with your game.</p></li>
				<li> <p> The callback is provided since it's likely that this step will require loading of external images
					and audio files from the server, which may take some time to complete. By calling the callback you
					are signifying that you are ready to begin drawing the canvas.
			</ul>
		
		<li><a id="drawBoard"><i>drawBoard()</i></a>
			<ul>
				<li><p>Upon receipt of the resetGameboard callback, the Test Arena starts the draw loop. 
				Now approximately 60 times a second your drawBoard function will be called 
				by the Test Arena to redraw the canvas.
				<li><p>This will automatically end once the user has chosen to end the game, or the game 
				has finished animating all game states.
			</ul>
	
		<li><a id="processGameData"><i>processGameData(messageType, gameData, callback)</i></a>
			<ul>
				<li><p> Called upon receipt of every GameState. 
				<li><p> Update the internal state of the client's representation of the game. So that subsequent 
					calls to GAME.drawBoard() reflect these changes.
			</ul>	
		
		<li><a id="processDebugData"><i>processDebugData(messageType, debugData, callback)</i></a>
			<ul>
				<li><p> Called immediately following receipt of the callback from <i>GAME.processGameData(...)</i>
				<li><p> Likely the debugData object will contain content best displayed in the Standard Output, Standard Error,
					Move List, and Board List divs.
				<li><p> <b>TODO:</b> Future developers may want to consider re-thinking the existence and purpose of this method.
					<ul>
						<li><p> It seems it may be more intuitive and flexible to replace both processGameData and processDebugData with a 
							single method that is passed the entire JSON GameState generated by the java game class. 
						<li><p> In addition, the scrollboxes at the bottom of the page for Standard Output, Standard Error,
								Move List, and Board List are currently hard coded into the page's HTML. These may not be desired for
								all games and that space may be better used for other purposes. As a result it may be beneficial to 
								make that region of the page a blank div that can be filled and managed programmatically by the Game javascript
								file.
					</ul>
			</ul>	
		
		<li><a id="processAnimatableEvent"><i>processAnimatableEvent(animatableEvent, callback)</i></a>
			<ul>
				<li><p> Called once for each animatableEvent in a GameState's animatableEvents array. The first call to this will
					occur immediately following the callback from processDebugData() and will contain the first element of the array. 
					Subsequent calls will be made for each element of the array in order, scheduled by the receipt of the callback from
					the previous call to processAnimatableEvent(...). 
			</ul>	
		
		<li><a id="setHumanInputElements"><i>setHumanInputElements()</i></a>
			<ul>
				<li><p> Called upon receipt of a GameState containing a truthy value for the enableHumanInput property.
				<li><p> Expected to set the innerHTML of the div with id "humanInputElements". 
				<li><p> Note you do not need to worry about unsetting anything previously added to 
							this div, the Test Arena automatically clears out any contents after the human 
							submits their move. You also do not need to provide any kind of submit button,
							the Test Arena provides one for you.
			</ul>	
		
		<li><a id="getMoveFromHumanInputElements"><i>getMoveFromHumanInputElements()</i></a>
			<ul>	
				<li> <p> Called after the human has submitted their move. This method is expected to read
					and parse the move from the humanInputElements div. 
				<li> <p> You must return a string that has the same exact structure that bots are expected to submit via their standard
					output streams. This move will be passed along through the system all the way to your Game.java
					file, where you'll be able to perform validation and update the internal game state before
					sending back the next GameState.
			</ul>
	
	</ul>

	
      <footer class="site-footer">
        <span class="site-footer-credits">Parts of this page were generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
