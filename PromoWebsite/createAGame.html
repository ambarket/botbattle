<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Bot!Battle! Documentation</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Bot!Battle!</h1>
	  <br>
      <a href="./index.html" class="btn">Main</a>
      <a href="./downloads.html" class="btn">Downloads</a>
      <a href="./documentation.html" class="btn">Documentation</a>
      <a href="./support.html" class="btn">Support</a>
      <a href="./about.html" class="btn">About</a>
      <br>
	  <h2> System Documentation! </h2>
      <a href="./designDocuments.html" class="btn">Design Documents</a>
      <a href="./createAGame.html" class="btn">Creating a Game</a>

    </section>

    <section class="main-content">
      <h1> Creating a Game </h1>
      
      <h2> What makes up a Game? </h2>
      <p>A Bot!Battle! Game consists of 4 components that must be uploaded to the initial configuration page.</p>
      <ul>
		<li> 
			<p><b>Game Name:</b> This name will be URL encoded and then used both in local storage file paths and urls to all game specific files and resources.
			<ul> 
				<li>  All  files uploaded and derived from your uploads to initial configuration page will be stored in
					<ul>
						<li>  application_root/local_storage/game_modules/[Game Name]
					</ul>
				<li>  All game specific hosted files will be available at urls rooted at
					<ul>
						<li>  /game/[Game Name]
					</ul>
				</li>
		
			</ul>
		</li>
		<br>
		<li> 
			<p><b>Game Rules</b>: A pdf file containing the rules of the game.
			<ul>
				<li> Hosted at: /game/[Game Name]/rules
			</ul>
		</li>
		<br>
		<li>  
			<p> <b>Game.java file</b> â€“ Please refer to the following java doc for help writing this class and implementing
				the GameInterface.
			<ul>
				<li> <a href = "GameInterfaceJavaDoc/index.html"> GameInterface JavaDoc</a>
			</ul>
		</li>
		<br>
		<li>  
			<p><b>Game Javascript</b> - [fileName].js
			<ul>
				<li>  Hosted at: /game/[Game Name]/javascript
				<li>  The built in test arena javascript file (testArena.js) will automatically load this file when the test arena page is loaded.
				<li>  This file must implement a global javascript object named GAME that has a number of required methods that are called directly by the built in test arena javascript file. These will be described in detail below.
			</ul>
		</li>
		<br>
		<li>  
			<p> <b>Game Resources</b>: A zip archive containing any additional files and folders that you would like to be hosted by Bot!Battle!
			<ul>
				<li>  Hosted at: /game/[Game Name]/resources/[Unzipped Resources]
				<li>  This allows you to upload sprites, images, audio, and any anything else that your game javascript file might require to display and animate the game to the user. 
			</ul>
		</li>
      </ul>
      <!-- ------------------------------------------------------------------------ -->
<h1> Client Side Documentation </h1>
<p> The following section is arranged as follows.

<ul>
	<li> <p> <a href="#globalObject">GLOBAL Object</a>
	<li> <p> <a href="#drawableObjects">Drawable Objects</a>
	<li> <p> <a href="#testArenaObject">TEST_ARENA Object</a>
	<li> <p> <a href="#pageStates">Test Arena Page States</a>
	<li> <p> <a href="#gameJavascript">Game Javascript</a>
	<li> <p> <a href="#jsonGameStates"> JSON GameStates</a>
	<li> <p> <a href="#gameStateExamples"> JSON GameState Examples</a>
	
	
	
</ul>

<h2> <a name="globalObject"> GLOBAL object (global.js) </a> </h2>
	<p>The global.js file provides a number of useful functionalities for error logging and some convenience methods for
	performing tasks such as appending information to div elements. 
	<p> One that may be the most immedietely useful when writing and debugging your game is the eventLog's logMessage function.
	<pre>
		var type = "status"|"warning"|"error"|other
		var message = "An error occured"
		GLOBAL.eventLog.logMessage(type, message)</pre>
	<p> This function will...
		<ol>
			<li><p>Apply a color to the message based on the type. Green for status, orange for warning, red for error, and the 
					inherited color for any other value. 
			<li><p>Flash your message at the top of the page for 3 seconds or until a new message is logged.
			<li><p>Add that message to the page's event log.
		</ol> 
	<p> Several other functions are available in the GLOBAL object defined in this file. Open the file to discover them.
	


<h2> <a name="drawableObjects"> Drawable Objects (drawable.js)</a> </h2>
	<p> The drawable.js file defines several convenience objects that implement the constructor pattern.
	<p><b>The constructor for each type takes a single options object as an argument. </b> The options available
		to each type are specified below.
			
	<p><b>All of the below types have their own overridden version of the <i>draw()</i> method.</b> This makes it very 
		convenient to simply store all your drawable objects in a structure, then have your <i>GAME.drawBoard()</i>
		method loop through that structure and call <i>draw()</i> on each of them. 
	
	<p> See <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial">https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial</a>
		for more information and clarifications on the options below. 

	<p> Required options are indicated with a <span style="color:red;">* </span>
	<ul>
		<li><p><b>drawableObject</b>: The most basic drawable element. 
			<p> All other drawables derive from this object and share all of the following options.
			<ul>
				<li><p><u>x </u><span style="color:red;">*</span>  : The x position (pixels) of this object's top left corner on the canvas.
				<li><p><u>y </u><span style="color:red;">*</span>: The y position (pixels) of this object's top left corner on the canvas.
				<li><p><u>width </u> <span style="color:red;">*</span>: The pixel difference between the top left and top right corner.
				<li><p><u>height </u><span style="color:red;">*</span>: The pixel difference between the top left and bottom left corner.
			</ul>
		<li><p><b>drawableRectangle</b>: Add a few more options onto drawableObject to support borders.
			<p> Extra Options:
			<ul>
				<li><p><u>borderWidth</u>: Defaults to 1 (px)
				<li><p><u>fillStyle</u>: Defaults to 'white'
				<li><p><u>strokeStyle</u>: Defaults to 'black'
			</ul>
		<li><p><b>drawableImage</b>: dd a few more options onto drawableObject to support loading an image from a file, and mapping a specific region of that
			image to a particular region on the canvas.
			<p> Extra Options:
			<ul>
				<li><p><u>imageSrc </u><span style="color:red;">*</span>: url to the image file.
				<li><p><u>loadedCallback </u><span style="color:red;">*</span>: A function to call when the image has been loaded into memory
					and is ready for use.
				<li><p><u>sourceX, sourceY, sourceWidth, sourceHeight</u>
					<ul>
						<li><p>These properties allow you to crop a specific region of the
							entire source image to be drawn into the canvas space specified by the x, y, width, and height options.
						<li><p> If not specified, these default to the values of the x, y, width, height attributes respecively.
						<li><p> See <a href= "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage">canvas drawImage documentation</a>
							for more information regarding how this works.
					</ul>
				<li><p><u>visible</u> A boolean attribute indicating whether this image should be drawn to the canvas upon 
					calls to <i>draw()</i>. 
					<ul>
						<li><p> Defaults to true.
						<li><p>You will likely programmatically alter this attribute as your game is running. 
					</ul>
			</ul>

		<li><p><b>drawableSprite</b>: Extends the drawableImage object to allow automatic looping through a horizontal sprite sheet.
			<p> This is accomplished by dividing your entire image into a number of frames. 
			<p> Extra Options:
			<ul>
				<li><p><u>indexStart</u>: Indicates the frame index to start at. Defaults to 0. 
				<li><p><u>numberOfFrames</u>: Divide your image into this number of equal width frames. Defaults to 1.
				
				<li><p><u>ticksPerFrame</u>: Number of calls to <i>draw()</i> before changing to the next frame. 
					<ul>
						<li><p>Defaults to 1.
						<li><p>You'll need to play around with this for your particular sprites but we found values between 8 and 12
						to be useful for the running, attack, and defend sprites in Save The Island.
					</ul>
				<li><p><u>loop</u>: A boolean attribute indicating whether the sprite should return back to frame index 0
					after finishing looping through all of the frames in the sprite sheet. 
			</ul>
			<p> Note regarding drawableSprite.draw()
			<ul>
				<li><p> When numberOfFrames == 1, it is drawn exactly as a drawableImage would be, passing the
					sourceX, sourceY, sourceWidth, sourceHeight, x, y, width, height properties along to
					context.drawImage(...) without modification.
				<li><p> When numberOfFrames > 1

					<ul>
						<li><p>	the sourceWidth used in the context.drawImage call is computed as sourceWidth / numberOfFrames. 
							Thus the sourceWidth should always be set to the actual width of the entire spritesheet.
						<li><p>sourceX is ignored and computed as currentFrameIndex * sourceWidth / numberOfFrames
					</ul>
			</ul>
	</ul>	

<h2><a id="testArenaObject"> TEST_ARENA Object (testArena.js)</a></h2>
	<p> The testArena.js file defines and maintains a global TEST_ARENA object. The following attributes of this
		object may be useful for game developers.
	<ul>
		<li><p><b>canvas</b>: A reference to the HTML5 Canvas element of the Test Arena. 
			<ul><li><p>This is the same as <i>document.getElementById("GameCanvas");</i></p></li></ul>
			
		<li><p><b>context</b>: A 2D drawing context of the HTML5 Canvas.
			<ul><li><p>This is the same as <i>document.getElementById("GameCanvas").getContext('2d');</i></p></li></ul>
			
		<li><p><b>scale</b>: A numeric variable indicating the relative width of the canvas element on the page
			<ul>
				<li><p> The default canvas size is set to 1050 x 650 px by <i>TEST_ARENA.resizeCanvas()</i>
				<li><p>This scale property is set to the current canvas width divided by 1050 and should be used 
					when calculating the scaled sizes of your sprites and animations. 
				<li><p>If using any of the drawable objects in drawable.js, you likely do not need to worry about
						scaling as they will be automatically scaled in the draw methods of these objects.
			</ul>
		<li><p><b>state</b>: One of the <a href="#pageStates">Test Arena Page States</a>.
	</ul>	

<h2><a id="pageStates"> Test Arena Page States </a></h2>
	<p> The Test Arena never reloads the page; instead, based on the results of various AJAX requests,
	 and user interaction with the GUI, the testArena.js file handles the transitions between the following states. 
	
	<ul>
		<li><p><b>pageLoaded</b>: When the page is first loaded, as well as after any HTTP or client javascript errors and 
			exceptions are thrown. 
			<ul><li><p>The "Play a Game" or "Share a Bot" forms are available to the user.</li></ul>
			
		
		<li><p><b>uploaded</b>: After the user has successfully uploaded bot(s).
			<ul>
				<li><p>The "Start Game" button is displayed.</li>
				<li><p>NOTE: This state is also triggered if the user clicks "Kill Game" on an already running game.
					Based on experience from the tournament it may be beneficial to  replace the button text with "Restart Game" or do
					something else to clearly indicate to the user that they are playing again with the same configuration, even if they
					make changes to the upload bots form in the meantime.
			</ul>
			
		<li><p><b>loadingGame</b>: After the user has clicked "Start Game". 
			<ul>
				<li><p>The upload form and "Start Game" button are hidden and the "Kill Game" button is displayed.
				<li><p>On the server side the GameManager and bots are started. 
				<li><p>Client side, the Test Arena begins making periodic AJAX requests to the server for the latest 
				JSON Game States generated by your Game java class. These AJAX requests will continue until the game has ended.
			</ul>
		<li><p><b>gameStarted</b>: After the initialGameState has been received from your Game java class and before your
			Game javascript file has processed it.
			<ul><li><p>No UI transitions occur. The Test Arena keeps listening for more game states.</li></ul>
		
		<li><p><b>gameFinished</b>: After the finalGameState has been completely processed by your Game javascript file.
			<ul>
				<li><p>NOTE: This appears to be functionally equivalent to just transitioning back to the uploaded
					state. Future developers should consider removing this state as its no longer seems to serve a unique purpose.
			</ul>
	</ul>	

<h2><a id="gameJavascript"> Game Javascript </a></h2>
	<p>
		Your Game java class is responsible for implementing all game logic required for validating moves, tracking the state of the game, and
		determining when someone has won or the game has otherwise ended. Your game javascript file is then responsible for 
		actually animating and presenting the results of the game to the user in the test arena. 
	<p>	The code in your Game java class sends updates to your Game javascript file using JSON GameStates. These will be
		described in detail below.
	<p> Your game javascript file must implement the following functions as properties of a global object named GAME. These functions
		will be invoked by the built in testArena.js file when necessary.
		
	<ul>
		<li><a id="setExtraGameControls"><i>setExtraGameControls()</i> </a>
		<ul><li><p> Will be called after each page state transition. The idea is that based on the new value of TEST_ARENA.state
			you may want to add or remove your own custom HTML elements from the Test Arena. In the Save The Island game,
			this was used for displaying the "Toggle Tiles" button when the page state was "gameStarted".</p></li></ul>
				
		<li><a id="resetGameboard"><i>resetGameboard(callback)</i></a>
			<ul>
				<li><p>Called upon receipt of the initialGameState. Should completely clear out and lose reference to 
				any data or state related to a previous game that was played. Since the test arena is never reloaded, 
				its important to make sure this is done fully at this step to avoid quirky behavior with your game.</p></li>
				<li> <p> The callback is provided since it's likely that this step will require loading of external images
					and audio files from the server, which may take some time to complete. By calling the callback you
					are signifying that you are ready to begin drawing the canvas.
			</ul>
		
		<li><a id="drawBoard"><i>drawBoard()</i></a>
			<ul>
				<li><p>Upon receipt of the resetGameboard callback, the Test Arena starts the draw loop. 
				Now approximately 60 times a second your drawBoard function will be called 
				by the Test Arena to redraw the canvas.
				<li><p>This will automatically end once the user has chosen to end the game, or the game 
				has finished animating all game states.
			</ul>
	
		<li><a id="processGameData"><i>processGameData(messageType, gameData, callback)</i></a>
			<ul>
				<li><p> Called upon receipt of every GameState. 
				<li><p> Update the internal state of the client's representation of the game. So that subsequent 
					calls to GAME.drawBoard() reflect these changes.
			</ul>	
		
		<li><a id="processDebugData"><i>processDebugData(messageType, debugData, callback)</i></a>
			<ul>
				<li><p> Called immediately following receipt of the callback from <i>GAME.processGameData(...)</i>
				<li><p> Likely the debugData object will contain content best displayed in the Standard Output, Standard Error,
					Move List, and Board List divs.
				<li><p> <b>TODO:</b> Future developers may want to consider re-thinking the existence and purpose of this method.
					<ul>
						<li><p> It seems it may be more intuitive and flexible to replace both processGameData and processDebugData with a 
							single method that is passed the entire JSON GameState generated by the java game class. 
						<li><p> In addition, the scrollboxes at the bottom of the page for Standard Output, Standard Error,
								Move List, and Board List are currently hard coded into the page's HTML. These may not be desired for
								all games and that space may be better used for other purposes. As a result it may be beneficial to 
								make that region of the page a blank div that can be filled and managed programmatically by the Game javascript
								file.
					</ul>
			</ul>	
		
		<li><a id="processAnimatableEvent"><i>processAnimatableEvent(animatableEvent, callback)</i></a>
			<ul>
				<li><p> Called once for each animatableEvent in a GameState's animatableEvents array. The first call to this will
					occur immediately following the callback from processDebugData() and will contain the first element of the array. 
					Subsequent calls will be made for each element of the array in order, scheduled by the receipt of the callback from
					the previous call to processAnimatableEvent(...). 
			</ul>	
		
		<li><a id="setHumanInputElements"><i>setHumanInputElements()</i></a>
			<ul>
				<li><p> Called upon receipt of a GameState containing a truthy value for the enableHumanInput property.
				<li><p> Expected to set the innerHTML of the div with id "humanInputElements". 
				<li><p> Note you do not need to worry about unsetting anything previously added to 
							this div, the Test Arena automatically clears out any contents after the human 
							submits their move. You also do not need to provide any kind of submit button,
							the Test Arena provides one for you.
			</ul>	
		
		<li><a id="getMoveFromHumanInputElements"><i>getMoveFromHumanInputElements()</i></a>
			<ul>	
				<li> <p> Called after the human has submitted their move. This method is expected to read
					and parse the move from the humanInputElements div. 
				<li> <p> You must return a string that has the same exact structure that bots are expected to submit via their standard
					output streams. This move will be passed along through the system all the way to your Game.java
					file, where you'll be able to perform validation and update the internal game state before
					sending back the next GameState.
			</ul>
	
	</ul>


<h2><a id="jsonGameStates">JSON Game States</a> </h2>

	<p>	There are three key GameInterface methods related to the generation of JSON GameStates, namely </p>
		<ul>
			<li> <a href="GameInterfaceJavaDoc/GameInterface.html#getInitialGameStateJSON--">getInitialGameStateJSON()</a>
			<li> <a href="GameInterfaceJavaDoc/GameInterface.html#getMidGameStateJSON-java.lang.String-java.lang.String-int-">getMidGameStateJSON(String jsonSafeMove, String jsonSafeStderrArray, int player)</a>
			<li> <a href="GameInterfaceJavaDoc/GameInterface.html#getFinalGameStateJSON--">getFinalGameStateJSON()</a>
		</ul>
	
	<p>
		As you might expect, getInitialGameStateJSON() is called once before the game has begun.
		getMidGameStateJSON(...) is called after each valid move is performed. And getFinalGameStateJSON() is
		called once after the game has ended. 
	<p> The following section attempts to formally define these game states and how they are handled by the Test Arena.
	</p>
	
	<h3>Components of a GameState</h3>
	<p> Each game state whether, initial, mid, or final, may have the following top level properties. </p>
	
	<pre>
    "{
    	"messageType":"initialGameState"|"midGameState"|"finalGameState",
    	"gameData": {	
    	    // Arbitrary game specific object
    	},
    	"debugData": {
    	    // Arbitrary game specific object
    	}
    	"animatableEvents":[
    	    // Array of arbitrary game specific objects.
    	],
        "enableHumanInput": truthy|falsy,
    }"
	</pre>

	
	<h4>"messageType" : "initialGameState"|"midGameState"|"finalGameState"</h4>  
			<ul>
				<li> <p>Tells the built in testArena.js file how to interpret your message
				<li> <p><b>initialGameState</b>: Receipt of a GameState with this special messageType triggers the 
					test arena to reset itself and prepare to animate a new game, to do so the following actions are
					performed.
					<ol>
						<li> <p>Transition to the gameStarted page state.
						<li> <p><a href="#resetGameboard"><i>GAME.resetGameboard(callback)</i></a>

						<li> <p><a href="#drawBoard"><i>GAME.drawBoard()</i> </a>

						<li> <p><a href="#passGameStateToGame"><i>passGameStateToGame()</i> </a>
					</ol>
				<li> <p><b>midGameState</b>: Indicates that the game is still in progress. The following actions are performed.
					<ol>
						<li><p><a href="#passGameStateToGame"><i>passGameStateToGame()</i> </a>
						<li><p> Continue requesting more GameStates from the server
					</ol>
				<li> <p><b>finalGameState</b>: Receipt of a GameState with the "finalGameState" messageType informs the
					Test Arena that the game is ending. The following actions are performed.
					<ol>
						<li><p> <a href="#passGameStateToGame"><i>passGameStateToGame()</i> </a>
						<li><p> Transition to gameFinished page state.
					</ol>
			</ul>

	<h4>"enableHumanInput" : truthy|falsy </h4>  
		<ul>
			<li> <p> If falsey (including undefined or not present), the Test Arena javascript will do nothing.
			<li> <p> If truthy, you're indicating to the Test Arena javascript that the human player is up next. 
						In response the Test Arena performs the following actions in order.
				<ol>
					<li> <p><a href="#setHumanInputElements"><i>GAME.setHumanInputElements()</i> </a>
						
					<li> <p>The humanInputElements div is then displayed to the user. And the application waits for
							their input.
					<li> <p><a href="#getMoveFromHumanInputElements"><i>GAME.getMoveFromHumanInputElements()</i> </a>
	
					<li> <p>After sending the move out to the GameManager the contents of the humanInputElements div are cleared,
						and the Test Arena continues to wait for new GameStates from your java Game class.
				</ol>
		</ul>
		
	<h4><a id="passGameStateToGame"> passGameStateToGame()</a></h4>
		<p> Upon receipt of every JSON GameState, regardless of its messageType and value for enableHumanInput, this private
			Test Arena function is called to sequence the processing of the game specific information by your GAME object. 
			Your GAME methods will be called in the following order. See the definitions of these methods for more details.
		<p> Below you'll find some psuedocode to emphazise the order and sceduling of the calls to your GAME methods. 
		<p> This was actually implemented using the <a href="https://github.com/caolan/async">aysnc</a> node module. Which makes 
			running javascript functions in series or parallel very easy and is exportable as a single javascript file 
			for use in client side javascript.
		<pre>
<span style="color:black;">function passGameStateToGame() { </span>
    <a href="#processGameData">GAME.processGameData(messageType, gameData, function()</a> <span style="color:black;">{</span>
        <a href="#processDebugData">GAME.processDebugData(messageType, debugData, function()</a> <span style="color:black;">{</span>
            <span style="color:black;">foreach (animatableEvent in animatableEvents) { </span>
                <a href="#processAnimatableEvent">GAME.processAnimatableEvent(animatableEvent, function()</a> <span style="color:black;">{</span> 
                   <span style="color:green;"> // Move to next iteration of this loop </span>
                <span style="color:black;">});</span>
            <span style="color:black;">}</span>
        <span style="color:black;">});</span>
    <span style="color:black;">});</span>
<span style="color:black;">}</span>
		</pre>

<h2> <a id="gameStateExamples">JSON Game State Examples</a> </h2>
<p> The following section has some actual game states used by the save the island game.

<h3> InitialGameState</h3>
<pre>
"{
	"messageType":"initialGamestate",
	"enableHumanInput":false,
	"gameData":{"player1Tiles":[3,4,3,4,4],
	"player2Tiles":[1,4,1,2,3],
	"turnDescription":"The game has started"}
 }"
</pre>
	
<h3> MidGameState</h3>
<pre>
"{
	"messageType":"midGamestate",
	"enableHumanInput":false,
	"animatableEvents":[
		{	
			"event":"move",
			"data": {
				"player":"player1",
				"endPosition":4,
				"startPosition":0
			}
		}
	],
	"gameData": {
		"player1Tiles":[3,4,3,4,4],
		"player2Tiles":[1,4,1,2,3],
		"turnDescription":"Player 1 moves forward 4 spaces."
	},
	"debugData": {
		"board":"1;34344;000010000000002",
		"stderr":["Player 1: \"1;34344;100000000000002\""],
		"stdout":"Player 1: \"move;4\""
	}
}"
</pre>

<h3> FinalGameState</h3>
<pre>
"{
	"messageType":"finalGamestate",
	"enableHumanInput":false,
	"gameData":{
		"player1Tiles":[3,2,3,3,3],
		"player2Tiles":[3,3,2,3,2],
		"turnDescription":"Player 2 has won the game."
	}
}"
</pre>
	
      <footer class="site-footer">
        <span class="site-footer-credits">Parts of this page were generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
